1.队列
	队列是一个有序列表，可以使用数组或链表来实现，遵循"先进先出"原则,即现存入的数据要先取出来，后存的数组要后取
1.1数组模拟队列的思路
	缺点：数组只可以用一次，数据不可以重复使用，这时为了效率，可以采用数组来模拟环形队列
1.2数据模拟环形队列(优化方法：取模的方式算法)
	思路：
	   1.front指针含义调整--》原先指向数组的第一个元素的前一个，现在指向数组的第一个元素
	   2.rear变量也调整--》      原先指向队列的最后一个元素位置，   现在rear变量指向队列的最后一个元素的后一个位置希望空出一个空间做调整
	     rear初始值=0
	   3.原先队列满条件：rear=maxSize-1;现在：(rear+1)%maxSize==front;
	   4.原先队列空条件：rear==front
	   5.当我们这样分析，队列中的有效个数是：(rear+maxSize-front)%maxSize;
	   6.就可以在原先的基础上得到一个环形队列
2.链表(LinkedList)
	1.也是一个有序的列表，分为带头结点的链表和不带头节点的链表
	2.链表是以结点的方式来存储，每个结点包含数据域和指针域，next指针域指向下一个结点，
	3.链表的各个结点不一定是连续存储的
2.1需要按照编号的顺序大小添加元素时：
    1.首先找到新节点添加的位置，通过辅助结点来找(比如我们把3结点插入到2和4结点中) ,遍历来找
      1  ->  2 ->   4  ->  5      ->3
    2.新节点.next=temp.next;   -->  3.next=temp.next
      temp.next=新节点           --》temp.next=3
2.2删除结点的思路
	1.首先我们要找到要删除结点的前一个结点；temp
	   temp.next=temp.next.next
	   被删除的结点没有任何引用指向时，会被jvm垃圾回收机制删除
3.双向链表
	单链表不可以自我删除，需要借助辅助指针，而双向链表不需要辅助指针，可以自我删除

3.1增删改查思路
	1.遍历：和单链表的思路一致
	2.添加：
	          先找到双向链表的最后    temp.next=new HeroNode  newHeroNode.pre=temp;
	3.修改也是和单链表的思路一致
	4.删除  因为是双向链表，可以自我删除，直接找到要删除的结点，比如：temp
	    temp.pre.next=temp.next
	    temp.next.pre=temp.pre;
4.单向环形链表(约瑟夫问题)
	n个人  从第k个人开始数数，数m下，出列，然后让下一个人开始继续数m，数到的人出列，以此类推。。。形成一个出队顺序。
4.1构建单链表的思路：
	1.先创建一个结点，让first指针指向该节点，形成环形
	2.后面我们没创建一个新节点，就加入这个环形链表

	遍历环形链表：
		先让一个辅助指针curBoy(变量),指向first结点	,然后通过循环遍历改环形链表即可， curBoy.next=first结束。
	3.根据用户的输入，生成一个出圈顺序
5.栈
	是限制线性表中元素的删除和插入只能在线性表的同一端进行的一种特殊线性表，允许插入和删除的一端，为变化的一端称为栈顶，另一端为
	固定的一端，称为栈底。
5.1根据栈的定义可知，最先放入的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素先删除最先放入的元素最后删除。
5.2数组模拟栈
	思路分析：
	定义一个top：表示栈顶，初始值为-1
	入栈操作：  当有数据加入的时候，top++，stack[top]=data;
	出栈操作： 当有数据出去的时候，int value=stack[top],top--,return value;
5.2用栈来实现综合计算器(中缀表达式)思路：
    需要俩个栈，一个数栈，一个符号栈；
    1.通过一个index值（索引），来遍历我们的表达式
    2.如果发现是一个数字，就直接入数栈
    3.如果扫描的是一个符号，就分如下情况：
        1.发现当前符号栈为空，直接入栈，
        2.如果符号栈有操作符，就要进行比较，如果当前操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出俩个数，再从符号栈pop出
        一个符号，进行运算，将得到结果，放入数栈，然后将当前的操作符放入符号栈
        3.如果当前操作符的优先级大于栈中的操作符，直接放入操作符栈
        4.当表达式扫描完毕后，就顺序的从数栈和符号栈pop出相应的数和符号，并运行
        5.最后再数栈中只有一个数，就是表达式的结果
5.3栈的三种表达式
    1.前缀表达式（波兰表达式）：前缀表达式的运算符位于操作数之前  --从右向左扫描
    2.中缀表达式（计算机不使用该方式，便于人正常理解）：
    3.后缀表达式（逆波兰表达式）：后缀表达式的运算符位于操作符之后   --从左向右扫描
6.哈希表数据结构（散列表）
    是根据关键码值而直接进行访问的数据结构，也就是说，通过把关键码值映射到表中的一个位置来访问记录，加快查找速率，z这个映射函数叫散列函数，
    存放记录的数组叫散列表
7.树（数据结构）：使用树可以提高存储和访问的效率，
                  A
                /    \
               B      C
              / \   /  \
             D   E  F    G
            /
           H
7.1树的常用语：
    根、根结点，子节点，父节点、叶子结点（没有子节点的结点：H、E、F、G）
    路径：从root结点找到该节点的路线  层  子树，树的高度（最大层数：4）
7.2二叉树：
    每个结点最多只可以有俩个子节点的树叫二叉树   -->左、右结点
7.3满二叉树
    如果二叉树的叶子结点都在最后一层，且结点个数是2^n-1个，其中n为数的层数，这样的数叫做满二叉树。
7.4完全二叉树
    如果该二叉树的所有叶子结点都在最后一层或者倒数第二层，而且最后一层的叶子结点在左面连续，倒数第二层的叶子
    结点在右边连续，该树就是完全二叉树。
                   A
                 B   C
                C E F E
               H K
7.5二叉树的遍历
    前序遍历：先遍历父节点，再遍历左子树，最后遍历右子树
    中序遍历：先遍历左子树，再遍历父节点，最后遍历右子树
    后序遍历：先遍历左子树，再遍历右子树，最后遍历父节点
7.6二叉树的查找
7.7二叉树的删除
    如果删除的是叶子结点，直接删除改结点
    如果删除的是非叶子结点，则删除改子树；